static const char *RcsId = "$Header: /users/chaize/newsvn/cvsroot/Instrumentation/CCD/ImgGrabber/Device/src/ImgGrabber.cpp,v 1.2 2010-09-14 14:49:20 vince_soleil Exp $";
//+=============================================================================
//
// file :         ImgGrabber.cpp
//
// description :  C++ source for the ImgGrabber and its commands. 
//                The class is derived from Device. It represents the
//                CORBA servant object which will be accessed from the
//                network. All commands which can be executed on the
//                ImgGrabber are implemented in this file.
//
// project :      TANGO Device Server
//
// $Author: vince_soleil $
//
// $Revision: 1.2 $
//
// $Log: not supported by cvs2svn $
// Revision 1.1.2.4  2010/04/20 12:04:35  nleclercq
// Still trying to fix int types conflict!
//
// Revision 1.1.2.3  2010/04/20 11:28:43  vince_soleil
// replaced by version from HEAD
//
// Revision 1.16  2010/04/20 08:53:41  nleclercq
// Fixing int types conflict
//
// Revision 1.15  2010/04/20 08:38:36  nleclercq
// Fixing int types conflict
//
// Revision 1.14  2010/04/07 13:25:30  ollupac
// Now the Slot gets a SharedImage
//
// This way it can decide to make a cheap duplicate and process it asynchronously.
//
// Revision 1.13  2010/04/07 13:24:21  ollupac
// Add events to ImageCounter
//
// Revision 1.12  2009/10/26 09:45:41  ollupac
// buggy DEV_ULONG -> buggy ImageCounter
//
// Revision 1.11  2009/08/27 09:33:49  ollupac
// Fix to work on 64 bitsOpenSuSe-11.1.
//
// Revision 1.10  2009/03/26 15:28:53  julien_malik
// include Ramon Sune evolutions :
// - direct memory-link with ImgBeamAnalyzer
// - PylonV2 Basler plugin
// - synchronization fixes
// - ImageCounter attribute
// - linux compilation
//
// Revision 1.9  2008/05/20 14:08:03  julien_malik
// modification of the IMAQ plugin to have 1 to 4 devices in one dserver instance, one per channel.
// big modification of the dynamic attributes management
//
// Revision 1.7  2008/03/07 11:19:30  julien_malik
// - plugins are now loaded at init and unloaded only at program exit
// - PylonInitialize & PylonTerminate are now properly called because of first item
// - GetPluginInfo implemented
//
// Revision 1.6  2008/03/05 13:31:57  julien_malik
// - add 'SaveSettings' command
// - support external trigger for Basler cameras
//
// Revision 1.5  2008/01/28 13:44:35  julien_malik
// HSYNC_TRIGGER mode instead of SOFTWARE_TRIGGER mode
//
// Revision 1.4  2007/10/23 16:29:28  julien_malik
// rework the movie saving
//
// Revision 1.3  2007/10/09 14:46:42  julien_malik
// - support new plugin system
// - add AutoStart property
// - Add properties for the BaslerGrabber to save the desired init value of exposure time, frame rate, gain and black level
//
// Revision 1.2  2007/09/11 09:19:04  julien_malik
// - bug fix for setting exposure time correctly
// - ExposureTime attribute display changed
//
// Revision 1.1  2007/08/20 15:03:20  stephle
// initial import
//
//
// copyleft :     European Synchrotron Radiation Facility
//                BP 220, Grenoble 38043
//                FRANCE
//
//-=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================


//===================================================================
//
//	The following table gives the correspondance
//	between commands and method's name.
//
//  Command's name  |  Method's name
//	----------------------------------------
//  State           |  dev_state()
//  Status          |  dev_status()
//  Open            |  open()
//  Close           |  close()
//  Start           |  start()
//  Stop            |  stop()
//  StartSaveMovie  |  start_save_movie()
//  StopSaveMovie   |  stop_save_movie()
//  Snap            |  snap()
//  SetROI          |  set_roi()
//  GetROI          |  get_roi()
//  ResetROI        |  reset_roi()
//  SaveSettings    |  save_settings()
//  GetPluginInfo   |  get_plugin_info()
//
//===================================================================


//#include <tango.h>
//#include <ImgGrabber.h>
#include <ImgGrabberClass.h>

#include <yat4tango/PlugInAttr.h>
#include <yat4tango/PlugInHelper.h>
#include <GrabberPluginManager.h>
#include <GrabberTask.h>
#include <GrabberAttr.h>
#include <isl/ErrorHandler.h>

#define MAX_STRING_LEN 1024

namespace ImgGrabber_ns
{

//+----------------------------------------------------------------------------
//
// method : 		ImgGrabber::ImgGrabber(string &s)
// 
// description : 	constructor for simulated ImgGrabber
//
// in : - cl : Pointer to the DeviceClass object
//      - s : Device name 
//
//-----------------------------------------------------------------------------
ImgGrabber::ImgGrabber(Tango::DeviceClass *cl,string &s)
:Tango::Device_3Impl(cl,s.c_str())
{
	init_device();
}

ImgGrabber::ImgGrabber(Tango::DeviceClass *cl,const char *s)
:Tango::Device_3Impl(cl,s)
{
	init_device();
}

ImgGrabber::ImgGrabber(Tango::DeviceClass *cl,const char *s,const char *d)
:Tango::Device_3Impl(cl,s,d)
{
	init_device();
}
//+----------------------------------------------------------------------------
//
// method : 		ImgGrabber::delete_device()
// 
// description : 	will be called at device destruction or at init command.
//
//-----------------------------------------------------------------------------
void ImgGrabber::delete_device()
{
  // Delete device's allocated object

  this->del_image_available_observer(this->image_change_notify_slot);

  if (this->grabber_task)
  {
    try
    {
      this->grabber_task->exit();
      this->grabber_task = 0;
    }
    catch(...)
    {
    }
  }
  SAFE_RELEASE(this->last_image);

  /*
  SAFE_DELETE_PTR( this->plugin_helper );
  SAFE_DELETE_PTR( this->dyn_attr_helper );
  */

  isl::ErrorHandler::reset();
}


void ImgGrabber::add_image_available_observer(SlotType ob)
{
  this->image_available_observer_sig.connect(ob);
}


void ImgGrabber::del_image_available_observer(SlotType ob)
{
  this->image_available_observer_sig.disconnect(ob);
}


//+----------------------------------------------------------------------------
//
// method : 		ImgGrabber::init_device()
// 
// description : 	will be called at device initialization.
//
//-----------------------------------------------------------------------------
void ImgGrabber::init_device()
{
	INFO_STREAM << "ImgGrabber::ImgGrabber() create device " << device_name << endl;

	// Initialise variables to default values
	//--------------------------------------------
  isl::ErrorHandler::init();
  this->last_image = 0;
  this->grabber_task = 0;

  //- Allocate the dynamic attribute helper
  try
  {
    this->grabber_task = new GrabAPI::GrabberTask(this->image_available_observer_sig);
  }
  catch(...)
  {
    this->set_status ("Initialization error [allocation failed]");
    this->set_state (Tango::FAULT);
    this->delete_device();
    return;
  }

  //- Get the device properties
  try
  {
	  this->get_device_property();
  }
  catch(...)
  {
    this->set_status ("Initialization error [get_property failed]");
    this->set_state (Tango::FAULT);
    this->delete_device();
    return;
  }

  if (this->pluginLocation == "undefined")
  {
    this->set_status ("Initialization error [PluginLocation property is undefined]");
    this->set_state (Tango::FAULT);
    this->delete_device();
    return;
  }

  if (this->moviePath == "undefined")
  {
    this->set_status ("Initialization error [MoviePath property is undefined]");
    this->set_state (Tango::FAULT);
    this->delete_device();
    return;
  }

  //- Load the plugin
  GrabAPI::IGrabber* grabber = 0;
  yat::IPlugInObject* plugin_obj = 0;  
  try
  {
    std::pair<yat::IPlugInInfo*, yat::IPlugInFactory*> plugin;
    plugin = GrabAPI::GrabberPluginManager::instance().load( this->pluginLocation );

    if (plugin.first->get_interface_name() != GrabAPI::kIGrabberInterfaceName)
    {
      THROW_YAT_ERROR("BAD_PLUGIN",
                      "The provided plugin does not implement the IGrabber interface", 
                      "ImgGrabber::init_device");
    }

    plugin.second->create( plugin_obj );

    this->plugin_info = plugin.first->get_plugin_id() + "\n" + plugin.first->get_version_number();

    try
    {

#ifdef WIN32
      grabber = dynamic_cast<GrabAPI::IGrabber*>(plugin_obj);
#else
      /// @todo Windows version is clearly better, but it will not work on
      /// linux. Some things should be done to get dynamic_cast between
      /// an object created in a .SO and the main application to work, and
      /// I don't think it is worth it now. We are already checking the
      /// interface name, so it's not like if we were just casting "anything"
      /// to GrabAPI::IGrabber.
      grabber = static_cast<GrabAPI::IGrabber*>(plugin_obj);
#endif
      if (grabber == 0)
        throw std::bad_cast();
    }
    catch( std::bad_cast & )
    {
      THROW_YAT_ERROR("BAD_CAST",
                      "The created object is not a IGrabber implementation", 
                      "ImgGrabber::init_device") ;
    }
  }
  catch(yat::Exception& ex)
  {
    yat::OSStream os;
    os << "Initialization error ["
       << ex.errors[0].desc
       << "]"
       << std::ends;

    this->set_status (os.str());
    this->set_state (Tango::FAULT);
    this->delete_device();
    return;
  }
  catch(...)
  {
    this->set_status ("Initialization error [Unknwon error when loading the plugin]");
    this->set_state (Tango::FAULT);
    this->delete_device();
    return;
  }


  //- Create the common attributes : ExposureTime / FrameRate
  try
  {
    yat::PlugInAttrInfo exposure_time_attr;
    exposure_time_attr.name = "ExposureTime";
    exposure_time_attr.data_type = yat::PlugInDataType::DOUBLE;
    exposure_time_attr.write_type = yat::PlugInAttrWriteType::READ_WRITE;
    exposure_time_attr.label = "Exposure Time";
    exposure_time_attr.desc = "Exposure time in millisecond";
    exposure_time_attr.unit = "ms";
    exposure_time_attr.display_format = "%8.3f";
    exposure_time_attr.set_cb = yat::SetAttrCB::instanciate( *grabber, &GrabAPI::IGrabber::set_exposure_time );
    exposure_time_attr.get_cb = yat::GetAttrCB::instanciate( *grabber, &GrabAPI::IGrabber::get_exposure_time );

    yat::PlugInAttrInfo frame_rate_attr;
    frame_rate_attr.name = "FrameRate";
    frame_rate_attr.data_type = yat::PlugInDataType::DOUBLE;
    frame_rate_attr.write_type = yat::PlugInAttrWriteType::READ_WRITE;
    frame_rate_attr.label = "Frame Rate";
    frame_rate_attr.desc = "Frame rate in frame per second";
    frame_rate_attr.unit = "fps";
    frame_rate_attr.display_format = "%3.1f";
    frame_rate_attr.set_cb = yat::SetAttrCB::instanciate( *grabber, &GrabAPI::IGrabber::set_frame_rate );
    frame_rate_attr.get_cb = yat::GetAttrCB::instanciate( *grabber, &GrabAPI::IGrabber::get_frame_rate );
    
    yat::PlugInAttrInfo resulting_frame_rate_attr;
    resulting_frame_rate_attr.name = "ResultingFrameRate";
    resulting_frame_rate_attr.data_type = yat::PlugInDataType::DOUBLE;
    resulting_frame_rate_attr.write_type = yat::PlugInAttrWriteType::READ;
    resulting_frame_rate_attr.label = "Resulting Frame Rate";
    resulting_frame_rate_attr.desc = "Number of fps that the device is handling";
    resulting_frame_rate_attr.unit = "fps";
    resulting_frame_rate_attr.display_format = "%3.1f";
    resulting_frame_rate_attr.get_cb = yat::GetAttrCB::instanciate( *grabber_task, &GrabAPI::GrabberTask::get_resulting_frame_rate );

    yat::PlugInAttrInfo bit_depth_attr;
    bit_depth_attr.name = "BitDepth";
    bit_depth_attr.data_type = yat::PlugInDataType::INT32;
    bit_depth_attr.write_type = yat::PlugInAttrWriteType::READ;
    bit_depth_attr.label = "Bit Depth";
    bit_depth_attr.desc = "Bit Depth";
    bit_depth_attr.unit = " ";
    bit_depth_attr.display_format = "%2d";
    bit_depth_attr.get_cb = yat::GetAttrCB::instanciate( *grabber, &GrabAPI::IGrabber::get_bit_depth );

    yat::PlugInAttrInfo sensor_width_attr;
    sensor_width_attr.name = "SensorWidth";
    sensor_width_attr.data_type = yat::PlugInDataType::INT32;
    sensor_width_attr.write_type = yat::PlugInAttrWriteType::READ;
    sensor_width_attr.label = "Sensor Width";
    sensor_width_attr.desc = "Sensor Width";
    sensor_width_attr.unit = " ";
    sensor_width_attr.display_format = "%4d";
    sensor_width_attr.get_cb = yat::GetAttrCB::instanciate( *grabber, &GrabAPI::IGrabber::get_sensor_width );

    yat::PlugInAttrInfo sensor_height_attr;
    sensor_height_attr.name = "SensorHeight";
    sensor_height_attr.data_type = yat::PlugInDataType::INT32;
    sensor_height_attr.write_type = yat::PlugInAttrWriteType::READ;
    sensor_height_attr.label = "Sensor Height";
    sensor_height_attr.desc = "Sensor Height";
    sensor_height_attr.unit = " ";
    sensor_height_attr.display_format = "%2d";
    sensor_height_attr.get_cb = yat::GetAttrCB::instanciate( *grabber, &GrabAPI::IGrabber::get_sensor_height );

    yat::PlugInAttrInfo image_counter_attr;
    image_counter_attr.name = "ImageCounter";
    image_counter_attr.data_type = yat::PlugInDataType::UINT32;
    image_counter_attr.write_type = yat::PlugInAttrWriteType::READ;
    image_counter_attr.label = "Image Counter";
    image_counter_attr.desc = "Image Counter";
    image_counter_attr.unit = "images";
    image_counter_attr.display_format = "%4d";
    image_counter_attr.get_cb = yat::GetAttrCB::instanciate( *grabber_task, &GrabAPI::GrabberTask::get_image_counter );

    GrabAPI::GrabberAttrManager::instance().register_attr( this, exposure_time_attr );
    GrabAPI::GrabberAttrManager::instance().register_attr( this, frame_rate_attr );
    GrabAPI::GrabberAttrManager::instance().register_attr( this, resulting_frame_rate_attr );
    GrabAPI::GrabberAttrManager::instance().register_attr( this, bit_depth_attr );
    GrabAPI::GrabberAttrManager::instance().register_attr( this, sensor_width_attr );
    GrabAPI::GrabberAttrManager::instance().register_attr( this, sensor_height_attr );
    GrabAPI::GrabberAttrManager::instance().register_attr( this, image_counter_attr );
  }
  catch(yat::Exception& ex)
  {
    yat::OSStream os;
    os << "Initialization error ["
       << ex.errors[0].desc
       << "]"
       << std::ends;

    this->set_status (os.str());
    this->set_state (Tango::FAULT);
    this->delete_device();
    return;
    }
  catch(Tango::DevFailed& ex)
  {
    yat::OSStream os;
    os << "Initialization error ["
       << ex.errors[0].desc
       << "]"
       << std::ends;

    this->set_status (os.str());
    this->set_state (Tango::FAULT);
    this->delete_device();
    return;
  }
  catch(...)
  {
    this->set_status ("Unknown error while creating attribute");
    this->set_state (Tango::FAULT);
    this->delete_device();
    return;
  }

  //- Set the plugin properties & Create the plug in attributes
  try
  {
    this->register_plugin_properties( grabber );

    yat::PlugInAttrInfoList attr_list;
    try
    {
      grabber->enumerate_attributes( attr_list );
      
      if (!attr_list.empty())
      {
        yat::PlugInAttrInfoList::iterator it;
        for (it = attr_list.begin(); it != attr_list.end(); it++)
        {
          GrabAPI::GrabberAttrManager::instance().register_attr( this, *it );
        }
      }
    }
    catch(yat::Exception& ex)
    {
      RETHROW_YAT_ERROR(ex,
                        "SOFTWARE_FAILURE",
                        "Error while registering plugin attributes",
                        "PlugInHelper::register_attributes");
    }
    catch(...)
    {
      THROW_YAT_ERROR("UNKNOWN_ERROR",
                      "Error while registering plugin attributes",
                      "PlugInHelper::register_attributes");
    }
  }
  catch(yat::Exception& ex)
  {
    yat::OSStream os;
    os << "Initialization error ["
       << ex.errors[0].desc
       << "]"
       << std::ends;

    this->set_status (os.str());
    this->set_state (Tango::FAULT);
    this->delete_device();
    return;
  }
  catch(...)
  {
    this->set_status ("Unknown error while registering plugin");
    this->set_state (Tango::FAULT);
    this->delete_device();
    return;
  }

  //- Set up a slot to get new image notifications -> it pushes ImgCtr events
  {
    this->image_change_notify_slot = SlotType::instanciate(
            *this,
            &ImgGrabber::notify_image_change);
    this->add_image_available_observer(this->image_change_notify_slot);
    this->set_change_event("ImageCounter", true);
  }

  try
  {
    yat::Message* init_msg = yat::Message::allocate(yat::TASK_INIT, INIT_MSG_PRIORITY, true);
    GrabAPI::GrabberTaskInit task_init_cfg;
    task_init_cfg.grabber = grabber;
    task_init_cfg.auto_start = this->autoStart;
    task_init_cfg.device = this;

    init_msg->attach_data(task_init_cfg);
    this->grabber_task->go(init_msg);

    if (task_init_cfg.auto_start)
      this->save_settings();

  }
  catch(yat::Exception& ex)
  {
    yat::OSStream os;
    os << "Initialization error ["
       << ex.errors[0].desc
       << "]"
       << std::ends;

    this->set_status (os.str());
    this->set_state (Tango::FAULT);
    //this->delete_device();
    return;
  }
  catch(Tango::DevFailed& ex)
  {
    yat::OSStream om;
    om << "Initialization error ["
       << ex.errors[0].desc
       << "]"
       << std::ends;

    this->set_status (om.str());
    this->set_state (Tango::FAULT);
    //this->delete_device();
    return;
  }
  catch(...)
  {
    this->set_status ("Initialization error [initialization of ImgGrabber failed]");
    this->set_state (Tango::FAULT);
    //this->delete_device();
    return;
  }
}


//+----------------------------------------------------------------------------
//
// method : 		ImgGrabber::get_device_property()
// 
// description : 	Read the device properties from database.
//
//-----------------------------------------------------------------------------
void ImgGrabber::get_device_property()
{
	//	Initialize your default values here (if not done with  POGO).
	//------------------------------------------------------------------
  this->pluginLocation = "undefined";
  this->moviePath = "undefined";
  this->movieFormat = "AVI";
  this->autoStart = true;

	//	Read device properties from database.(Automatic code generation)
	//------------------------------------------------------------------
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("PluginLocation"));
	dev_prop.push_back(Tango::DbDatum("MoviePath"));
	dev_prop.push_back(Tango::DbDatum("MovieFormat"));
	dev_prop.push_back(Tango::DbDatum("AutoStart"));

	//	Call database and extract values
	//--------------------------------------------
	if (Tango::Util::instance()->_UseDb==true)
		get_db_device()->get_property(dev_prop);
	Tango::DbDatum	def_prop, cl_prop;
	ImgGrabberClass	*ds_class =
		(static_cast<ImgGrabberClass *>(get_device_class()));
	int	i = -1;

	//	Try to initialize PluginLocation from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  pluginLocation;
	//	Try to initialize PluginLocation from default device value
	def_prop = ds_class->get_default_device_property(dev_prop[i].name);
	if (def_prop.is_empty()==false)	def_prop  >>  pluginLocation;
	//	And try to extract PluginLocation value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  pluginLocation;

	//	Try to initialize MoviePath from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  moviePath;
	//	Try to initialize MoviePath from default device value
	def_prop = ds_class->get_default_device_property(dev_prop[i].name);
	if (def_prop.is_empty()==false)	def_prop  >>  moviePath;
	//	And try to extract MoviePath value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  moviePath;

	//	Try to initialize MovieFormat from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  movieFormat;
	//	Try to initialize MovieFormat from default device value
	def_prop = ds_class->get_default_device_property(dev_prop[i].name);
	if (def_prop.is_empty()==false)	def_prop  >>  movieFormat;
	//	And try to extract MovieFormat value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  movieFormat;

	//	Try to initialize AutoStart from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  autoStart;
	//	Try to initialize AutoStart from default device value
	def_prop = ds_class->get_default_device_property(dev_prop[i].name);
	if (def_prop.is_empty()==false)	def_prop  >>  autoStart;
	//	And try to extract AutoStart value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  autoStart;



	//	End of Automatic code generation
	//------------------------------------------------------------------

}
//+----------------------------------------------------------------------------
//
// method : 		ImgGrabber::always_executed_hook()
// 
// description : 	method always executed before any command is executed
//
//-----------------------------------------------------------------------------
void ImgGrabber::always_executed_hook()
{
  if (this->grabber_task)
  {
    GrabAPI::GrabberState state;
    std::string status;
    
    this->grabber_task->get_state_status(state, status);

    Tango::DevState devstate;
    switch (state)
    {
    case GrabAPI::OPEN:    devstate = Tango::OPEN;    break;
    case GrabAPI::CLOSE:   devstate = Tango::CLOSE;   break;
    case GrabAPI::RUNNING: devstate = Tango::RUNNING; break;
    case GrabAPI::FAULT:   devstate = Tango::FAULT;   break;
    case GrabAPI::UNKNOWN:
    default:               devstate = Tango::UNKNOWN; break;
    }

    this->set_state(devstate);
    this->set_status(status);
  }
}
//+----------------------------------------------------------------------------
//
// method : 		ImgGrabber::read_attr_hardware
// 
// description : 	Hardware acquisition for attributes.
//
//-----------------------------------------------------------------------------
void ImgGrabber::read_attr_hardware(vector<long> &/*attr_list*/)
{
	//	Add your own code here
  
  if (this->grabber_task == 0)
  {
    THROW_DEVFAILED("SOFTWARE_FAILURE",
                    "Device is not initialized properly",
                    "ImgGrabber::read_attr_hardware");
  }
  
  try
  {
    SAFE_RELEASE(this->last_image);
    this->last_image = this->grabber_task->get_last_image();
  }
  catch(yat::Exception& ex)
  {
    yat4tango::YATDevFailed df(ex);
    RETHROW_DEVFAILED(df,
                      "SOFTWARE_FAILURE",
                      "Error when releasing last image",
                      "ImgGrabber::read_attr_hardware");
  }
  catch(...)
  {
    THROW_DEVFAILED("SOFTWARE_FAILURE",
                    "Error when releasing last image",
                    "ImgGrabber::read_attr_hardware");
  }
}
//+----------------------------------------------------------------------------
//
// method : 		ImgGrabber::read_CurrentlySavingMovie
// 
// description : 	Extract real attribute values for CurrentlySavingMovie acquisition result.
//
//-----------------------------------------------------------------------------
void ImgGrabber::read_CurrentlySavingMovie(Tango::Attribute &attr)
{
  if (this->grabber_task == 0)
  {
    return;
  }

  this->is_saving_movie = this->grabber_task->is_saving_movie();
  attr.set_value(&this->is_saving_movie);
}

//+----------------------------------------------------------------------------
//
// method : 		ImgGrabber::read_MovieRemainingTime
// 
// description : 	Extract real attribute values for MovieRemainingTime acquisition result.
//
//-----------------------------------------------------------------------------
void ImgGrabber::read_MovieRemainingTime(Tango::Attribute &attr)
{
  if (this->grabber_task == 0)
  {
    return;
  }

  this->movie_remaining_time = this->grabber_task->movie_remaining_time();
  this->movie_remaining_time_cc = const_cast<char*>(this->movie_remaining_time.c_str());
  attr.set_value( &this->movie_remaining_time_cc );
}


//+----------------------------------------------------------------------------
//
// method : 		ImgGrabber::read_Image
// 
// description : 	Extract real attribute values for Image acquisition result.
//
//-----------------------------------------------------------------------------
void ImgGrabber::read_Image(Tango::Attribute &attr)
{
  if (this->last_image == NULL
      || this->last_image->get_image() == NULL)
  {
    return;
  }

  const GrabAPI::Image* image = this->last_image->get_image();

  attr.set_value(image->base(),
                 static_cast<long>(image->width()),
                 static_cast<long>(image->height()));
}


//+------------------------------------------------------------------
/**
 *	method:	ImgGrabber::open
 *
 *	description:	method to execute "Open"
 *
 *
 */
//+------------------------------------------------------------------
void ImgGrabber::open()
{
	DEBUG_STREAM << "ImgGrabber::open(): entering... !" << endl;

	//	Add your own code to control device here
  if (this->grabber_task == 0)
  {
    return;
  }

  try
  {
    yat::Message* msg = yat::Message::allocate( kMSG_OPEN, DEFAULT_MSG_PRIORITY, false );
    this->grabber_task->post(msg, 3000);
  }
  catch(yat::Exception& ex)
  {
    yat4tango::YATDevFailed df(ex);
    throw df;
  }
  catch(...)
  {
    THROW_DEVFAILED("UNKNOWN_ERROR",
                    "Unknown error while opening hardware access",
                    "ImgGrabber::open");
  }

}

//+------------------------------------------------------------------
/**
 *	method:	ImgGrabber::close
 *
 *	description:	method to execute "Close"
 *
 *
 */
//+------------------------------------------------------------------
void ImgGrabber::close()
{
	DEBUG_STREAM << "ImgGrabber::close(): entering... !" << endl;

	//	Add your own code to control device here
  if (this->grabber_task == 0)
  {
    return;
  }

  try
  {
    yat::Message* msg = yat::Message::allocate( kMSG_CLOSE, DEFAULT_MSG_PRIORITY, false );
    this->grabber_task->post(msg, 3000);
  }
  catch(yat::Exception& ex)
  {
    yat4tango::YATDevFailed df(ex);
    throw df;
  }
  catch(...)
  {
    THROW_DEVFAILED("UNKNOWN_ERROR",
                    "Unknown error while closing camera access",
                    "ImgGrabber::close");
  }
}

//+------------------------------------------------------------------
/**
 *	method:	ImgGrabber::start
 *
 *	description:	method to execute "Start"
 *
 *
 */
//+------------------------------------------------------------------
void ImgGrabber::start()
{
	DEBUG_STREAM << "ImgGrabber::start(): entering... !" << endl;

	//	Add your own code to control device here
  if (this->grabber_task == 0)
  {
    return;
  }

  try
  {
    yat::Message* msg = yat::Message::allocate( kMSG_START, DEFAULT_MSG_PRIORITY, true );
    this->grabber_task->wait_msg_handled(msg, 3000);
  }
  catch(yat::Exception& ex)
  {
    yat4tango::YATDevFailed df(ex);
    throw df;
  }
  catch(...)
  {
    THROW_DEVFAILED("UNKNOWN_ERROR",
                    "Unknown error while starting acquisition",
                    "ImgGrabber::start");
  }
}

//+------------------------------------------------------------------
/**
 *	method:	ImgGrabber::stop
 *
 *	description:	method to execute "Stop"
 *
 *
 */
//+------------------------------------------------------------------
void ImgGrabber::stop()
{
	DEBUG_STREAM << "ImgGrabber::stop(): entering... !" << endl;

	//	Add your own code to control device here
  if (this->grabber_task == 0)
  {
    return;
  }

  try
  {
    yat::Message* msg = yat::Message::allocate( kMSG_STOP, DEFAULT_MSG_PRIORITY, false );
    this->grabber_task->post(msg, 3000);
  }
  catch(yat::Exception& ex)
  {
    yat4tango::YATDevFailed df(ex);
    throw df;
  }
  catch(...)
  {
    THROW_DEVFAILED("UNKNOWN_ERROR",
                    "Unknown error while starting acquisition",
                    "ImgGrabber::start");
  }
}

//+------------------------------------------------------------------
/**
 *	method:	ImgGrabber::stop_save_movie
 *
 *	description:	method to execute "StopSaveMovie"
 *	immediately stops the movie saving
 *
 *
 */
//+------------------------------------------------------------------
void ImgGrabber::stop_save_movie()
{
	DEBUG_STREAM << "ImgGrabber::stop_save_movie(): entering... !" << endl;

	//	Add your own code to control device here
  if (this->grabber_task == 0)
  {
    return;
  }

  yat::Message* msg = yat::Message::allocate( kMSG_STOP_RECORDING, DEFAULT_MSG_PRIORITY, false );

  this->grabber_task->post(msg, 3000);
}

//+------------------------------------------------------------------
/**
 *	method:	ImgGrabber::snap
 *
 *	description:	method to execute "Snap"
 *
 *
 */
//+------------------------------------------------------------------
void ImgGrabber::snap()
{
	DEBUG_STREAM << "ImgGrabber::snap(): entering... !" << endl;

	//	Add your own code to control device here
  if (this->grabber_task == 0)
  {
    return;
  }


  try
  {
    yat::Message* msg = yat::Message::allocate( kMSG_SNAP, DEFAULT_MSG_PRIORITY, false );
    this->grabber_task->post(msg, 3000);
  }
  catch(yat::Exception& ex)
  {
    yat4tango::YATDevFailed df(ex);
    throw df;
  }
  catch(...)
  {
    THROW_DEVFAILED("UNKNOWN_ERROR",
                    "Unknown error while snaping one image",
                    "ImgGrabber::snap");
  }
}

//+------------------------------------------------------------------
/**
 *	method:	ImgGrabber::set_roi
 *
 *	description:	method to execute "SetROI"
 *
 * @param	argin	[origin_x, origin_y, width, height]
 *
 */
//+------------------------------------------------------------------
void ImgGrabber::set_roi(const Tango::DevVarLongArray *argin)
{
	//	Add your own code to control device here
  if (this->grabber_task == 0)
  {
    return;
  }

  try
  {
    GrabAPI::ROI roi;
    if (argin->length() != 4)
    {
      THROW_DEVFAILED("ARGUMENT_ERROR",
                      "Argument must contain 4 values : [offset_x, offset_y, width, height]",
                      "ImgGrabber::set_roi");
    }

    roi.x      = (*argin)[0];
    roi.y      = (*argin)[1];
    roi.width  = (*argin)[2];
    roi.height = (*argin)[3];
    yat::Message* msg = yat::Message::allocate( kMSG_SET_ROI, DEFAULT_MSG_PRIORITY, true );
    msg->attach_data(roi);
    this->grabber_task->wait_msg_handled(msg, 3000);
  }
  catch(yat::Exception& ex)
  {
    yat4tango::YATDevFailed df(ex);
    throw df;
  }
  catch(...)
  {
    THROW_DEVFAILED("UNKNOWN_ERROR",
                    "Unknown error while setting ROI",
                    "ImgGrabber::set_roi");
  }

}

//+------------------------------------------------------------------
/**
 *	method:	ImgGrabber::get_roi
 *
 *	description:	method to execute "GetROI"
 *
 * @return	[origin_x, origin_y, width, height]
 *
 */
//+------------------------------------------------------------------
Tango::DevVarLongArray *ImgGrabber::get_roi()
{
	//	POGO has generated a method core with argout allocation.
	//	If you would like to use a static reference without copying,
	//	See "TANGO Device Server Programmer's Manual"
	//		(chapter : Writing a TANGO DS / Exchanging data)
	//------------------------------------------------------------
	//	Add your own code to control device here

  if (this->grabber_task == 0)
  {
    return 0;
  }

  Tango::DevVarLongArray	*argout = 0;
  try
  {
    GrabAPI::ROI roi = this->grabber_task->get_roi();
	  argout  = new Tango::DevVarLongArray();
	  argout->length(4);
	  (*argout)[0] = roi.x;
	  (*argout)[1] = roi.y;
	  (*argout)[2] = roi.width;
	  (*argout)[3] = roi.height;
  }
  catch(yat::Exception& ex)
  {
    yat4tango::YATDevFailed df (ex);
    RETHROW_DEVFAILED(df,
                      "SOFTWARE_FAILURE",
                      "Error when getting ROI",
                      "ImgGrabber::get_roi");
  }
  catch(Tango::DevFailed& df)
  {
    RETHROW_DEVFAILED(df,
                      "SOFTWARE_FAILURE",
                      "Error when getting ROI",
                      "ImgGrabber::get_roi");
  }
	return argout;
}

//+------------------------------------------------------------------
/**
 *	method:	ImgGrabber::reset_roi
 *
 *	description:	method to execute "ResetROI"
 *
 *
 */
//+------------------------------------------------------------------
void ImgGrabber::reset_roi()
{
	DEBUG_STREAM << "ImgGrabber::reset_roi(): entering... !" << endl;

	//	Add your own code to control device here
  if (this->grabber_task == 0)
  {
    return;
  }

  yat::Message* msg = yat::Message::allocate( kMSG_RESET_ROI, DEFAULT_MSG_PRIORITY, true );

  try
  {
    this->grabber_task->wait_msg_handled(msg, 5000);
  }
  catch(yat::Exception& ex)
  {
    yat4tango::YATDevFailed df(ex);
    throw df;
  }
  catch(...)
  {
    THROW_DEVFAILED("UNKNOWN_ERROR",
                    "Unknown error while setting ROI",
                    "ImgGrabber::set_roi");
  }
}

//+------------------------------------------------------------------
/**
 *	method:	ImgGrabber::get_plugin_info
 *
 *	description:	method to execute "GetPluginInfo"
 *	Retrieves information about the grabber plugin used
 *
 * @return	
 *
 */
//+------------------------------------------------------------------
Tango::DevString ImgGrabber::get_plugin_info()
{
	//	POGO has generated a method core with argout allocation.
	//	If you would like to use a static reference without copying,
	//	See "TANGO Device Server Programmer's Manual"
	//		(chapter : Writing a TANGO DS / Exchanging data)
	//------------------------------------------------------------
	//	Add your own code to control device here
  Tango::DevString	argout  = new char[ plugin_info.size() ];
  strcpy( argout, plugin_info.c_str() );
	return argout;
}

//+------------------------------------------------------------------
/**
 *	method:	ImgGrabber::start_save_movie
 *
 *	description:	method to execute "StartSaveMovie"
 *	saves a movie in the directory specified in the MoviePath property, and with the format specified as MovieFormat.
 *
 * @param	argin	duration of the movie & file base-name
 *
 */
//+------------------------------------------------------------------
void ImgGrabber::start_save_movie(const Tango::DevVarDoubleStringArray *argin)
{
	DEBUG_STREAM << "ImgGrabber::start_save_movie(): entering... !" << endl;

	//	Add your own code to control device here
  if (this->grabber_task == 0)
  {
    return;
  }

  if (argin->dvalue.length() != 1 || argin->svalue.length() != 1 )
  {
    THROW_DEVFAILED("ARGUMENT_ERROR",
                    "The argument must contain 1 Numeric (the number of images to save) and 1 string (the files basename), for example [ 20, \"my_image\"] ",
                    "ImgGrabber::start_save_movie");
  }

  double      d = argin->dvalue[0];
  std::string s = (const char*)argin->svalue[0];

  yat::Message* msg = yat::Message::allocate( kMSG_START_RECORDING, DEFAULT_MSG_PRIORITY, true );

  GrabAPI::RecordMovieConfig rmconf;
  rmconf.file_basename = this->moviePath + s;
  rmconf.format = this->movieFormat;
  rmconf.duration_s = d;
  
  msg->attach_data(rmconf);

  try
  {
    this->grabber_task->wait_msg_handled(msg, 3000);
  }
  catch(yat::Exception& ex)
  {
    yat4tango::YATDevFailed df(ex);
    throw df;
  }
  catch(...)
  {
    THROW_DEVFAILED("UNKNOWN_ERROR",
                    "Unknown error while starting a movie",
                    "ImgGrabber::start_save_movie");
  }
}


//+------------------------------------------------------------------
/**
 *	method:	ImgGrabber::save_settings
 *
 *	description:	method to execute "SaveSettings"
 *	save the current acquisition parameters to the device Properties
 *
 *
 */
//+------------------------------------------------------------------
void ImgGrabber::save_settings()
{
	DEBUG_STREAM << "ImgGrabber::save_settings(): entering... !" << endl;

	//	Add your own code to control device here
  if (this->grabber_task == 0)
  {
    return;
  }

  yat::Message* msg = yat::Message::allocate( kMSG_SAVE_SETTING, DEFAULT_MSG_PRIORITY, true );

  try
  {
    this->grabber_task->wait_msg_handled(msg, 5000);
  }
  catch(yat::Exception& ex)
  {
    yat4tango::YATDevFailed df(ex);
    throw df;
  }
  catch(...)
  {
    THROW_DEVFAILED("UNKNOWN_ERROR",
                    "Unknown error while saving settings",
                    "ImgGrabber::save_settings");
  }
}


void ImgGrabber::register_plugin_properties( GrabAPI::IGrabber* object )
{
  try
  {
    //- get the list of properties that the plug-in wants
    yat::PlugInPropInfos prop_infos;
    try
    {
      object->enumerate_properties(prop_infos);
    }
    catch(yat::Exception& ex)
    {
      RETHROW_YAT_ERROR(ex,
                        "SOFTWARE_FAILURE",
                        "Error while enumerating plugin properties",
                        "PlugInHelper::register_properties");
    }
    catch(...)
    {
      THROW_YAT_ERROR("UNKNOWN_ERROR",
                      "Error while enumerating plugin properties",
                      "PlugInHelper::register_properties");
    }

    if ( prop_infos.empty() )
    {
      return;
    }

    //- create the corresponding Tango::DbData
    yat::PlugInPropInfos::const_iterator in_it;
    Tango::DbData property_query;
    std::insert_iterator<Tango::DbData> out_it(property_query, property_query.begin());
    for (in_it = prop_infos.begin(); in_it != prop_infos.end(); ++in_it)
    {
      *out_it = Tango::DbDatum( (*in_it).first );
    }
    
    //- fill in the Tango::DbData
    try
    {
      this->get_db_device()->get_property(property_query);
    }
    catch(Tango::DevFailed& df)
    {
      yat4tango::TangoYATException ex(df);
      RETHROW_YAT_ERROR(ex,
                        "SOFTWARE_FAILURE",
                        "Error while enumerating plugin properties",
                        "PlugInHelper::register_properties");
    }
    catch(...)
    {
      THROW_YAT_ERROR("UNKNOWN_ERROR",
                      "Error while enumerating plugin properties",
                      "PlugInHelper::register_properties");
    }



    //- extract the value from the Tango::DbData and copy them to a yat::PlugInPropValues
    yat::PlugInPropValues prop_values;
    Tango::DbData::iterator property_query_it;
    try
    {
      for ( property_query_it = property_query.begin();
            property_query_it != property_query.end();
            ++property_query_it )
      {
        std::string prop_name = (*property_query_it).name;

#       define YAT4TANGO_PUSH_PLUGIN_PROP_TYPE( TYPEID, TYPE )                      \
        case TYPEID:                                                                \
          {                                                                         \
            if ( !(*property_query_it).is_empty() )                                 \
            {                                                                       \
              TYPE value;                                                           \
              (*property_query_it) >> value;                                        \
              prop_values[prop_name] = value;                                       \
            }                                                                       \
          }                                                                         \
          break;

        switch (prop_infos[prop_name])
        {
          YAT4TANGO_PUSH_PLUGIN_PROP_TYPE( yat::PlugInPropType::BOOLEAN, bool );
          YAT4TANGO_PUSH_PLUGIN_PROP_TYPE( yat::PlugInPropType::UINT8, yat_uint8_t );
          YAT4TANGO_PUSH_PLUGIN_PROP_TYPE( yat::PlugInPropType::INT16, yat_int16_t );
          YAT4TANGO_PUSH_PLUGIN_PROP_TYPE( yat::PlugInPropType::UINT16, yat_uint16_t );
          YAT4TANGO_PUSH_PLUGIN_PROP_TYPE( yat::PlugInPropType::INT32, yat_int32_t );
          YAT4TANGO_PUSH_PLUGIN_PROP_TYPE( yat::PlugInPropType::UINT32, yat_uint32_t );
          YAT4TANGO_PUSH_PLUGIN_PROP_TYPE( yat::PlugInPropType::FLOAT, float );
          YAT4TANGO_PUSH_PLUGIN_PROP_TYPE( yat::PlugInPropType::DOUBLE, double );
          YAT4TANGO_PUSH_PLUGIN_PROP_TYPE( yat::PlugInPropType::STRING, std::string );
          YAT4TANGO_PUSH_PLUGIN_PROP_TYPE( yat::PlugInPropType::STRING_VECTOR, std::vector<std::string> );
          YAT4TANGO_PUSH_PLUGIN_PROP_TYPE( yat::PlugInPropType::INT16_VECTOR, std::vector<yat_int16_t> );
          YAT4TANGO_PUSH_PLUGIN_PROP_TYPE( yat::PlugInPropType::UINT16_VECTOR, std::vector<yat_uint16_t> );
          YAT4TANGO_PUSH_PLUGIN_PROP_TYPE( yat::PlugInPropType::INT32_VECTOR, std::vector<yat_int32_t> );
          YAT4TANGO_PUSH_PLUGIN_PROP_TYPE( yat::PlugInPropType::UINT32_VECTOR, std::vector<yat_uint32_t> );
          YAT4TANGO_PUSH_PLUGIN_PROP_TYPE( yat::PlugInPropType::FLOAT_VECTOR, std::vector<float> );
          YAT4TANGO_PUSH_PLUGIN_PROP_TYPE( yat::PlugInPropType::DOUBLE_VECTOR, std::vector<double> );
          default: THROW_YAT_ERROR("SOFTWARE_FAILURE","Unsupported property type","PlugInHelper::register_plugin");
        }
      }
    }
    catch(yat::Exception& ex)
    {
      RETHROW_YAT_ERROR(ex,
                        "SOFTWARE_FAILURE",
                        "Error while getting properties from database",
                        "PlugInHelper::register_properties");
    }
    catch(Tango::DevFailed& df)
    {
      yat4tango::TangoYATException ex(df);
      RETHROW_YAT_ERROR(ex,
                        "SOFTWARE_FAILURE",
                        "Error while getting properties from database",
                        "PlugInHelper::register_properties");
    }
    catch(...)
    {
      THROW_YAT_ERROR("UNKNOWN_ERROR",
                      "Error while getting properties from database",
                      "PlugInHelper::register_properties");
    }

    //- send the list filled with the values to the plugin
    try
    {
      object->set_properties( prop_values );
    }
    catch(yat::Exception& ex)
    {
      RETHROW_YAT_ERROR(ex,
                        "SOFTWARE_FAILURE",
                        "Error while setting properties of plugin",
                        "PlugInHelper::register_properties");
    }
    catch(...)
    {
      THROW_YAT_ERROR("UNKNOWN_ERROR",
                      "Error while setting properties of plugin",
                      "PlugInHelper::register_properties");
    }
  }
  catch( yat::Exception& e )
  {
    throw yat4tango::YATDevFailed( e );
  }
}

GrabAPI::SharedImage* ImgGrabber::get_last_image() const throw (yat::Exception)
  {
    if (this->last_image == NULL)
      THROW_YAT_ERROR("NO_IMAGE",
                      "There is no image to get yet.",
                      "ImageGrabber::get_last_image");

     return this->last_image->duplicate();
  }

void ImgGrabber::notify_image_change(const GrabAPI::SharedImage* simage)
  {
    yat::Any container;
    this->grabber_task->get_image_counter(container);
    yat_uint32_t value = yat::any_cast<yat_uint32_t>(container);
    
    this->push_change_event("ImageCounter", &value);
  }

}	//	namespace
